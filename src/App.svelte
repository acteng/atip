<script lang="ts">
  import type { FeatureCollection, Polygon } from "geojson";
  import { onMount } from "svelte";
  import authoritiesUrl from "../assets/authorities.geojson?url";

  import About from "./lib/About.svelte";
  import Instructions from "./lib/Instructions.svelte";
  import Map from "./lib/Map.svelte";
  import Layout from "./lib/Layout.svelte";
  import BoundaryLayer from "./lib/BoundaryLayer.svelte";
  import InterventionList from "./lib/InterventionList.svelte";
  import EntireScheme from "./lib/EntireScheme.svelte";
  import ZoomOutMap from "./lib/ZoomOutMap.svelte";
  import BaselayerSwitcher from "./lib/BaselayerSwitcher.svelte";
  import Legend from "./lib/Legend.svelte";

  import InterventionLayer from "./lib/draw/InterventionLayer.svelte";
  import HoverLayer from "./lib/draw/HoverLayer.svelte";
  import Toolbox from "./lib/draw/Toolbox.svelte";

  let showAbout = false;
  let showInstructions = false;

  // TODO This is a hacky way of detecting environment. 'npm run dev' and
  // Github should be false, and only Cloudfront should be true.
  let prod = window.location.hostname.includes("atip.uk");

  const params = new URLSearchParams(window.location.search);
  // TODO Add validation and some kind of error page
  let authorityName: string = params.get("authority")!;
  let style: string = params.get("style") || "streets";

  // TODO Slight hack. These files are stored in an S3 bucket, which only has
  // an HTTP interface. When deployed to Github pages over HTTPS, we can't mix
  // HTTP and HTTPS content, so use the Cloudfront HTTPS interface. That'll need
  // CDN invalidations when we update these files. But when serving locally for
  // development, HTTPS is also fine to use.
  var routeUrl = `https://atip.uk/route-snappers/${authorityName}.bin`;
  if (!prod) {
    routeUrl = `https://atip.uk/route-snappers-dev/${authorityName}.bin`;
  }

  function toggleAbout() {
    showAbout = !showAbout;
    showInstructions = false;
  }
  function toggleInstructions() {
    showInstructions = !showInstructions;
    showAbout = false;
  }

  let boundaryGeojson: FeatureCollection<Polygon>;
  onMount(async () => {
    boundaryGeojson = await loadAuthorityBoundary();
  });

  async function loadAuthorityBoundary(): Promise<FeatureCollection<Polygon>> {
    const resp = await fetch(authoritiesUrl);
    const body = await resp.text();
    const geojson: FeatureCollection<Polygon> = JSON.parse(body);
    geojson.features = geojson.features.filter(
      (feature) => feature.properties?.name == authorityName
    );
    return geojson;
  }
</script>

<Layout>
  <div slot="nav">
    <button type="button" on:click={() => window.open("index.html")}>
      Home</button
    >
    <button type="button" on:click={toggleAbout}>About</button>
    <button type="button" on:click={toggleInstructions}>Instructions</button>
  </div>
  <div slot="sidebar">
    <h1>{authorityName} <ZoomOutMap {boundaryGeojson} /></h1>
    <EntireScheme {authorityName} />
    <br />
    <InterventionList />
  </div>
  <div slot="main">
    <Map {style}>
      <BoundaryLayer {boundaryGeojson} />
      <InterventionLayer />
      <HoverLayer />
      <Toolbox {routeUrl} />
      <BaselayerSwitcher {style} />
      <Legend />
    </Map>
  </div>
</Layout>

<About bind:open={showAbout} />
<Instructions bind:open={showInstructions} />
